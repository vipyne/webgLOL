<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>webGLOL</title>
</head>
<body>
<script type="text/javascript">

function webglol() {
  // get canvas element
  var webglolCanvas = document.getElementById('webglol')
  // define WebGLRenderingContext
  //// getContext(context, options)
  var gl = webglolCanvas.getContext('experimental-webgl');

  // paint all the pixels on the canvas black at 20% alpha
  // this makes the background grey
  
  // Specifies the color values used when clearing color buffers.
  //// gl.clearColor(red, green, blue, alpha)
  gl.clearColor(0, 0, 0, .2); 

  // clears buffers to preset values specified by clearColor(), clearDepth() and clearStencil().
  //// gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT || gl.STENCIL_BUFFER_BIT)
  gl.clear(gl.COLOR_BUFFER_BIT);

  //// gl.createProgram();
  var webglolProgram = gl.createProgram();

  // create a WebGLShader
  // gl.createShader(gl.VERTEX_SHADER || gl.FRAGMENT_SHADER)
  var vertexShader   = gl.createShader(gl.VERTEX_SHADER);
  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

  // shaders
  // attribute- input value that changes the vertices, (vertex shader only)
  // vec3- 3D floating point vector
  var vertexShaderGLSL = "attribute vec3 pos;            " +
                         "void main() {                  " +
  // gl_Position- 4D vector representing the final processed vertex position. (vertex shader only)
  // first 3 values are passed in... 4th is a scaling thing.
                         " gl_Position = vec4(pos, 2.0); " +
  // gl_PointSize- contains size of rasterized points, in pixels
  // this is the `O`
                         " gl_PointSize = 65.0;          " +
                         "}                              ";

  // precision- qualifier precedes the type in the variable declaration
  // mediump- also, highp, lowp
  var fragmentShaderGLSL = "precision mediump float;                          " +
                           "void main() {                                      " +
  // distance(point1, vec2) returns the distance between two points or vector
  // gl_PointCoord- contains the coordinate of a fragment within a point (i think this is center)
                            // " float dist = distance(gl_PointCoord, vec2(0.5));  " +
  // smoothstep(edge0, edge1, x) returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0
                            // " float alpha = 1.0 - smoothstep(0.48, 0.5, dist);  " +
                            " gl_FragColor.a = 1.0;                           " + 
                            " gl_FragColor.r = 0.9;                             " + 
                            " gl_FragColor.g = 0.2;                             " + 
                            " gl_FragColor.b = 0.9;                             " + 
                            // " gl_FragColor = vec4(0.9, 0.2, 0.9, 1.0);                         " + 
                            "}                                                  ";
  // gl.shaderSource(shader, source)
  gl.shaderSource(vertexShader, vertexShaderGLSL);
  gl.shaderSource(fragmentShader, fragmentShaderGLSL);

  // gl.compileShader(shader)
  gl.compileShader(vertexShader);
  gl.compileShader(fragmentShader);

  // gl.attachShader(webgl program,  shader)
  gl.attachShader(webglolProgram, vertexShader);
  gl.attachShader(webglolProgram, fragmentShader);

  gl.linkProgram(webglolProgram);

  var triangleAttributePosition = gl.getAttribLocation(webglolProgram, 'pos');

  var numberOfTriangles = 100;

  var vertices = [ 0.0, 0.0, 0.0,
                   0.0, 0.0, 0.0 ];

  var degPerTri = (4 * Math.PI) / numberOfTriangles;

  for(var i = 0; i < numberOfTriangles; i++) {
      var index = 6 + i * 3;
      var angle = degPerTri * i;
      var scale = 2;
      // console.log('angle', angle)

      vertices[index] = Math.cos(angle) / scale; 
      // console.log('cos', vertices[index])
      vertices[index + 1] = Math.sin(angle) / scale; 
      // console.log('sin', vertices[index + 1])
      vertices[index + 2] = 0; 
  }

  vertices.push( -0.5, -0.5, 0.0, 
                 -1.5, -0.5, 0.0,
                 -1.5, 0.5, 0.0, // first `L`
                  0.5, 0.5, 0.0,
                  0.5, -0.5, 0.0,
                  1.5, -0.5, 0.0 ); // second `L`

  var rsize = 3;
  var verticesFloatArray = new Float32Array(vertices);

  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, verticesFloatArray, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(triangleAttributePosition);
  gl.vertexAttribPointer(triangleAttributePosition, rsize, gl.FLOAT, false, 0, 0);

  gl.useProgram(webglolProgram);

  // drawArrays(primatitve shape, start index, number of values to be rendered)
  gl.drawArrays(gl.TRIANGLES, numberOfTriangles + 2, 6); // draw the `L`s
  gl.drawArrays(gl.TRIANGLE_FAN, 0, numberOfTriangles - 5); // draw the `O`
}

window.onload = webglol;
// if we were animating, redraw every 200 ms
// setInterval(webglol, 200);

</script>
<canvas id="webglol" width="300" height="300"></canvas>
</body>
</html>